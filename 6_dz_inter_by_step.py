'''
Подготовьте программу, которая с помощью интерполяционного многочлена Ньютона будет вычислять в
точке приближённое значение функции, заданной набором своих значений, и оцените погрешность.
'''


def f(x):
    return x*x

# Определение функции факториала
def factorial(n):
    P = 1
    for i in range(1, n + 1):
        P = P * i
    return (P)


# Определение функции погрешности
def omega(x, x_k, n):
    P = 1
    for i in range(0, n + 1):
        P = P * (x - x_k[i])
    return (P)


# Определние набора данных
# x_k = [0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]  # [int(i) for i in input().split(' ')]
# f_k = [6, 6, 6, 4, 6, 4, 6, 4, 6, 4, 6, 4, 4, 5, 6, 7, 8]  # [int(i) for i in input().split(' ')]
# f_k = []
x_k = [-5,-4,-3,-2,-1, 0, 1, 2, 3, 4, 5, 6, 8, 10, 12]
# Y = np.array([6, 6, 6, 4, 6, 4, 6, 4, 6, 4, 6, 4, 4, 5, 6, 7, 8])
f_k = [-9,-10,-9,-8,-9,-9,-9,-7,-9,-3,-7,-4,-3,-1,1]
for i in range(0, len(x_k)):
    f_k.append(f(x_k[i]))
# Определение длины набора
l = len(x_k)

# Определение массивов, зависящих от l
S_k = [1 for i in range(0, l)]
A_k = [0 for i in range(0, l - 1)]

# Определение итогового значения
S = 0

# Определение матрицы для разделенных разностей
matrix = [[0] * (l + 1) for i in range(2 * l - 1)]

# Степень разности
k = 1

# Заполнение первого столбца матрицы
for i in range(0, l):
    matrix[2 * i][0] = x_k[i]
    matrix[2 * i][1] = f_k[i]

# Заполнение матрицы
for j in range(2, l + 1):
    # print('j = ', j)
    for i in range(k, 2 * l - 1 - k, 2):
        # print(i, j)
        matrix[i][j] = (matrix[i + 1][j - 1] - matrix[i - 1][j - 1]) / (
                    matrix[i + 1 + (k - 1)][0] - matrix[i - 1 - (k - 1)][0])
    k = k + 1
    # print('k = ', k)

# Степень разности
k = 1

# Извлечение из матрицы нужных нам разделенных разностей
for j in range(2, l + 1):
    for i in range(k, k + 1):
        A_k[k - 1] = matrix[i][j]
    k = k + 1

# Определение точки, в которой мы интерполируем функцию
x = 0  # float(input('Введите точку x: '))

# Нахождение значения многочлена Ньютона в точке x
for i in range(1, l):
    S_k[i] = S_k[i - 1] * (x - x_k[i - 1])
    S_k[0] = f_k[0]

S = S_k[0]

for i in range(1, l):
    S = S + S_k[i] * A_k[i - 1]

# Оценка найденного значения фукнции в точке x:
M = 0.02  # float(input('Введите оценку для n+1-производной в точке x: '))

# Определение степени полинома Ньютона
n = 0
for i in range(0, len(A_k)):
    if (A_k[i] != 0):
        n = n + 1

# Вычисление погрешности
delta = M * omega(x, x_k, n) / (factorial(n + 1))
print(S, ' +- ', delta)